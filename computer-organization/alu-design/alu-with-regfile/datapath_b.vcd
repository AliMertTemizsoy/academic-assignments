$date
	Wed Apr 16 19:28:40 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module datapath_tb_b $end
$var wire 1 ! overflow $end
$var wire 1 " carry $end
$var wire 32 # alu_result [31:0] $end
$var reg 2 $ addr1 [1:0] $end
$var reg 2 % addr2 [1:0] $end
$var reg 2 & addr3 [1:0] $end
$var reg 3 ' alu_control [2:0] $end
$var reg 1 ( clk $end
$var reg 1 ) rst $end
$var reg 1 * wr $end
$var integer 32 + i [31:0] $end
$scope module dut $end
$var wire 2 , addr1 [1:0] $end
$var wire 2 - addr2 [1:0] $end
$var wire 2 . addr3 [1:0] $end
$var wire 3 / alu_control [2:0] $end
$var wire 32 0 alu_result [31:0] $end
$var wire 1 ( clk $end
$var wire 1 ) rst $end
$var wire 1 * wr $end
$var wire 32 1 rd_data2 [31:0] $end
$var wire 32 2 rd_data1 [31:0] $end
$var wire 1 ! overflow $end
$var wire 1 " carry $end
$var wire 32 3 alu_out [31:0] $end
$scope module alu_inst $end
$var wire 3 4 alu_control [2:0] $end
$var wire 32 5 b_inverted [31:0] $end
$var wire 1 6 cin_for_sub $end
$var wire 32 7 xor_result [31:0] $end
$var wire 1 8 sum_msb $end
$var wire 32 9 sub_result [31:0] $end
$var wire 1 : slt_result $end
$var wire 32 ; slt_extended [31:0] $end
$var wire 32 < result [31:0] $end
$var wire 1 ! overflow $end
$var wire 1 = msb_b $end
$var wire 1 > msb_a $end
$var wire 1 ? cout_sub $end
$var wire 1 @ cout_add $end
$var wire 1 " carry $end
$var wire 32 A b [31:0] $end
$var wire 32 B and_result [31:0] $end
$var wire 32 C add_result [31:0] $end
$var wire 32 D a [31:0] $end
$scope module adder $end
$var wire 1 E cin $end
$var wire 33 F temp_sum [32:0] $end
$var wire 32 G sum [31:0] $end
$var wire 1 @ cout $end
$var wire 32 H b [31:0] $end
$var wire 32 I a [31:0] $end
$upscope $end
$scope module and_op $end
$var wire 32 J result [31:0] $end
$var wire 32 K b [31:0] $end
$var wire 32 L a [31:0] $end
$upscope $end
$scope module result_mux $end
$var wire 32 M add_result [31:0] $end
$var wire 32 N and_result [31:0] $end
$var wire 3 O select [2:0] $end
$var wire 32 P xor_result [31:0] $end
$var wire 32 Q sub_result [31:0] $end
$var wire 32 R slt_result [31:0] $end
$var reg 32 S result [31:0] $end
$upscope $end
$scope module slt_extender $end
$var wire 32 T o [31:0] $end
$var wire 1 : i $end
$upscope $end
$scope module slt_op $end
$var wire 1 U and_3_out $end
$var wire 1 V ctrl0 $end
$var wire 1 W ctrl1 $end
$var wire 1 > msb_a $end
$var wire 1 = msb_b $end
$var wire 1 X not_ctrl1 $end
$var wire 1 ! overflow $end
$var wire 1 : slt_result $end
$var wire 1 8 sum_msb $end
$var wire 1 Y xnor_3_out $end
$var wire 1 Z xor1_out $end
$upscope $end
$scope module subtractor $end
$var wire 32 [ b [31:0] $end
$var wire 1 6 cin $end
$var wire 33 \ temp_sum [32:0] $end
$var wire 32 ] sum [31:0] $end
$var wire 1 ? cout $end
$var wire 32 ^ a [31:0] $end
$upscope $end
$scope module xor_op $end
$var wire 32 _ result [31:0] $end
$var wire 32 ` b [31:0] $end
$var wire 32 a a [31:0] $end
$upscope $end
$upscope $end
$scope module rf $end
$var wire 2 b addr1 [1:0] $end
$var wire 2 c addr2 [1:0] $end
$var wire 2 d addr3 [1:0] $end
$var wire 1 ( clk $end
$var wire 32 e data1 [31:0] $end
$var wire 32 f data2 [31:0] $end
$var wire 32 g data3 [31:0] $end
$var wire 1 ) rst $end
$var wire 1 * wr $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100100011010001010110011110000 g
b10010001101000101011001111000 f
b10010001101000101011001111000 e
b0 d
b0 c
b0 b
b10010001101000101011001111000 a
b10010001101000101011001111000 `
b0 _
b10010001101000101011001111000 ^
b0 ]
b100000000000000000000000000000000 \
b11101101110010111010100110000111 [
0Z
1Y
1X
0W
0V
0U
b0 T
b100100011010001010110011110000 S
b0 R
b0 Q
b0 P
b0 O
b10010001101000101011001111000 N
b100100011010001010110011110000 M
b10010001101000101011001111000 L
b10010001101000101011001111000 K
b10010001101000101011001111000 J
b10010001101000101011001111000 I
b10010001101000101011001111000 H
b100100011010001010110011110000 G
b100100011010001010110011110000 F
0E
b10010001101000101011001111000 D
b100100011010001010110011110000 C
b10010001101000101011001111000 B
b10010001101000101011001111000 A
0@
1?
0>
0=
b100100011010001010110011110000 <
b0 ;
0:
b0 9
08
b0 7
16
b11101101110010111010100110000111 5
b0 4
b100100011010001010110011110000 3
b10010001101000101011001111000 2
b10010001101000101011001111000 1
b100100011010001010110011110000 0
b0 /
b0 .
b0 -
b0 ,
bx +
0*
0)
0(
b0 '
b0 &
b0 %
b0 $
b100100011010001010110011110000 #
0"
0!
$end
#5
1(
#10
0(
b0 +
#12
b1 +
#14
b10 +
#15
1(
#16
b11 +
#18
0Y
0X
1V
1W
b0 #
b0 0
b0 3
b0 <
b0 S
b0 g
1*
b11 '
b11 /
b11 4
b11 O
b1 &
b1 .
b1 d
b100 +
#20
0(
#25
1(
#28
b1 ;
b1 R
b1 T
1:
18
1X
0Z
0V
0W
b11111111111111111111111111111111 #
b11111111111111111111111111111111 0
b11111111111111111111111111111111 3
b11111111111111111111111111111111 <
b11111111111111111111111111111111 S
b11111111111111111111111111111111 g
b11111111111111111111111111111111 5
b11111111111111111111111111111111 [
b11111111111111111111111111111111 7
b11111111111111111111111111111111 P
b11111111111111111111111111111111 _
b11111111111111111111111111111111 9
b11111111111111111111111111111111 Q
b11111111111111111111111111111111 ]
b0 B
b0 J
b0 N
b11111111111111111111111111111111 C
b11111111111111111111111111111111 G
b11111111111111111111111111111111 M
1>
b0 '
b0 /
b0 4
b0 O
b0 &
b0 .
b0 d
b0 1
b0 A
b0 H
b0 K
b0 `
b0 f
b1 %
b1 -
b1 c
b111111111111111111111111111111111 \
b11111111111111111111111111111111 F
b11111111111111111111111111111111 2
b11111111111111111111111111111111 D
b11111111111111111111111111111111 I
b11111111111111111111111111111111 L
b11111111111111111111111111111111 ^
b11111111111111111111111111111111 a
b11111111111111111111111111111111 e
b10 $
b10 ,
b10 b
1*
#30
0(
#35
1(
#38
b1 ;
b1 R
b1 T
1:
18
0?
1Z
1V
0"
b11111111111111111111111111111111 #
b11111111111111111111111111111111 0
b11111111111111111111111111111111 3
b11111111111111111111111111111111 <
b11111111111111111111111111111111 S
b11111111111111111111111111111111 g
b11111111111111111111111111111110 5
b11111111111111111111111111111110 [
b1 7
b1 P
b1 _
b11111111111111111111111111111111 9
b11111111111111111111111111111111 Q
b11111111111111111111111111111111 ]
b1 C
b1 G
b1 M
0>
b1 '
b1 /
b1 4
b1 O
b10 &
b10 .
b10 d
b1 1
b1 A
b1 H
b1 K
b1 `
b1 f
b11 %
b11 -
b11 c
b11111111111111111111111111111111 \
b1 F
b0 2
b0 D
b0 I
b0 L
b0 ^
b0 a
b0 e
b1 $
b1 ,
b1 b
1*
#40
0(
#45
1(
#48
b0 ;
b0 R
b0 T
0:
08
0V
1"
b0 #
b0 0
b0 3
b0 <
b0 S
b0 g
b11111111111111111111111111111110 7
b11111111111111111111111111111110 P
b11111111111111111111111111111110 _
b11111111111111111111111111111110 9
b11111111111111111111111111111110 Q
b11111111111111111111111111111110 ]
1?
b1 B
b1 J
b1 N
b0 C
b0 G
b0 M
1@
1>
b0 '
b0 /
b0 4
b0 O
b11 &
b11 .
b11 d
b111111111111111111111111111111110 \
b100000000000000000000000000000000 F
b11111111111111111111111111111111 2
b11111111111111111111111111111111 D
b11111111111111111111111111111111 I
b11111111111111111111111111111111 L
b11111111111111111111111111111111 ^
b11111111111111111111111111111111 a
b11111111111111111111111111111111 e
b0 $
b0 ,
b0 b
1*
#50
0(
#55
0Z
b1 ;
b1 R
b1 T
1:
18
b11111111111111111111111111111111 #
b11111111111111111111111111111111 0
b11111111111111111111111111111111 3
b11111111111111111111111111111111 <
b11111111111111111111111111111111 S
b11111111111111111111111111111111 g
0"
b11111111111111111111111111111111 9
b11111111111111111111111111111111 Q
b11111111111111111111111111111111 ]
b11111111111111111111111111111111 7
b11111111111111111111111111111111 P
b11111111111111111111111111111111 _
b0 B
b0 J
b0 N
b11111111111111111111111111111111 C
b11111111111111111111111111111111 G
b11111111111111111111111111111111 M
0@
b111111111111111111111111111111111 \
b11111111111111111111111111111111 5
b11111111111111111111111111111111 [
b11111111111111111111111111111111 F
b0 1
b0 A
b0 H
b0 K
b0 `
b0 f
1(
#58
b0 +
0*
#60
b1 +
0(
#62
b10 +
#64
b11 +
#65
1(
#66
b100 +
#70
0(
#75
1(
#76
