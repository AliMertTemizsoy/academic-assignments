$date
	Wed Apr 16 19:05:09 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module alu_tb $end
$var wire 32 ! result [31:0] $end
$var wire 1 " overflow $end
$var wire 1 # carry $end
$var reg 32 $ a [31:0] $end
$var reg 3 % alu_control [2:0] $end
$var reg 32 & b [31:0] $end
$scope module uut $end
$var wire 32 ' a [31:0] $end
$var wire 3 ( alu_control [2:0] $end
$var wire 32 ) b [31:0] $end
$var wire 32 * b_inverted [31:0] $end
$var wire 1 + cin_for_sub $end
$var wire 32 , xor_result [31:0] $end
$var wire 1 - sum_msb $end
$var wire 32 . sub_result [31:0] $end
$var wire 1 / slt_result $end
$var wire 32 0 slt_extended [31:0] $end
$var wire 32 1 result [31:0] $end
$var wire 1 " overflow $end
$var wire 1 2 msb_b $end
$var wire 1 3 msb_a $end
$var wire 1 4 cout_sub $end
$var wire 1 5 cout_add $end
$var wire 1 # carry $end
$var wire 32 6 and_result [31:0] $end
$var wire 32 7 add_result [31:0] $end
$scope module adder $end
$var wire 32 8 a [31:0] $end
$var wire 32 9 b [31:0] $end
$var wire 1 : cin $end
$var wire 33 ; temp_sum [32:0] $end
$var wire 32 < sum [31:0] $end
$var wire 1 5 cout $end
$upscope $end
$scope module and_op $end
$var wire 32 = a [31:0] $end
$var wire 32 > b [31:0] $end
$var wire 32 ? result [31:0] $end
$upscope $end
$scope module result_mux $end
$var wire 32 @ add_result [31:0] $end
$var wire 32 A and_result [31:0] $end
$var wire 3 B select [2:0] $end
$var wire 32 C xor_result [31:0] $end
$var wire 32 D sub_result [31:0] $end
$var wire 32 E slt_result [31:0] $end
$var reg 32 F result [31:0] $end
$upscope $end
$scope module slt_extender $end
$var wire 32 G o [31:0] $end
$var wire 1 / i $end
$upscope $end
$scope module slt_op $end
$var wire 1 H and_3_out $end
$var wire 1 I ctrl0 $end
$var wire 1 J ctrl1 $end
$var wire 1 3 msb_a $end
$var wire 1 2 msb_b $end
$var wire 1 K not_ctrl1 $end
$var wire 1 " overflow $end
$var wire 1 / slt_result $end
$var wire 1 - sum_msb $end
$var wire 1 L xnor_3_out $end
$var wire 1 M xor1_out $end
$upscope $end
$scope module subtractor $end
$var wire 32 N a [31:0] $end
$var wire 32 O b [31:0] $end
$var wire 1 + cin $end
$var wire 33 P temp_sum [32:0] $end
$var wire 32 Q sum [31:0] $end
$var wire 1 4 cout $end
$upscope $end
$scope module xor_op $end
$var wire 32 R a [31:0] $end
$var wire 32 S b [31:0] $end
$var wire 32 T result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 T
b0 S
b0 R
b0 Q
b100000000000000000000000000000000 P
b11111111111111111111111111111111 O
b0 N
0M
1L
1K
0J
0I
0H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
0:
b0 9
b0 8
b0 7
b0 6
05
14
03
02
b0 1
b0 0
0/
b0 .
0-
b0 ,
1+
b11111111111111111111111111111111 *
b0 )
b0 (
b0 '
b0 &
b0 %
b0 $
0#
0"
b0 !
$end
#10
b1111 !
b1111 1
b1111 F
b11111111111111111111111111111010 *
b11111111111111111111111111111010 O
b1111 7
b1111 <
b1111 @
b101 .
b101 D
b101 Q
b1111 ,
b1111 C
b1111 T
b101 &
b101 )
b101 9
b101 >
b101 S
b1111 ;
b100000000000000000000000000000101 P
b1010 $
b1010 '
b1010 8
b1010 =
b1010 N
b1010 R
#20
0L
1I
1#
b101 !
b101 1
b101 F
b1 %
b1 (
b1 B
#30
1M
b1 0
b1 E
b1 G
1/
1-
1L
0K
0#
04
0I
1J
b1111000000000000 !
b1111000000000000 1
b1111000000000000 F
b11111111111111110000000011111111 *
b11111111111111110000000011111111 O
b11110111111110000 7
b11110111111110000 <
b11110111111110000 @
b1111000000000000 6
b1111000000000000 ?
b1111000000000000 A
b11111111111111111111000111110000 .
b11111111111111111111000111110000 D
b11111111111111111111000111110000 Q
b111111110000 ,
b111111110000 C
b111111110000 T
b10 %
b10 (
b10 B
b1111111100000000 &
b1111111100000000 )
b1111111100000000 9
b1111111100000000 >
b1111111100000000 S
b11110111111110000 ;
b11111111111111111111000111110000 P
b1111000011110000 $
b1111000011110000 '
b1111000011110000 8
b1111000011110000 =
b1111000011110000 N
b1111000011110000 R
#40
0L
1I
b111111110000 !
b111111110000 1
b111111110000 F
b11 %
b11 (
b11 B
#50
1K
0J
b1 !
b1 1
b1 F
b11111111111111111111111111110101 *
b11111111111111111111111111110101 O
b1111 7
b1111 <
b1111 @
b0 6
b0 ?
b0 A
b11111111111111111111111111111011 .
b11111111111111111111111111111011 D
b11111111111111111111111111111011 Q
b1111 ,
b1111 C
b1111 T
b101 %
b101 (
b101 B
b1010 &
b1010 )
b1010 9
b1010 >
b1010 S
b1111 ;
b11111111111111111111111111111011 P
b101 $
b101 '
b101 8
b101 =
b101 N
b101 R
#60
1"
1H
1L
1M
b0 0
b0 E
b0 G
0/
1-
0I
b10000000000000000000000000000000 !
b10000000000000000000000000000000 1
b10000000000000000000000000000000 F
b11111111111111111111111111111110 *
b11111111111111111111111111111110 O
b10000000000000000000000000000000 7
b10000000000000000000000000000000 <
b10000000000000000000000000000000 @
b1 6
b1 ?
b1 A
b1111111111111111111111111111110 .
b1111111111111111111111111111110 D
b1111111111111111111111111111110 Q
14
b1111111111111111111111111111110 ,
b1111111111111111111111111111110 C
b1111111111111111111111111111110 T
b0 %
b0 (
b0 B
b1 &
b1 )
b1 9
b1 >
b1 S
b10000000000000000000000000000000 ;
b101111111111111111111111111111110 P
b1111111111111111111111111111111 $
b1111111111111111111111111111111 '
b1111111111111111111111111111111 8
b1111111111111111111111111111111 =
b1111111111111111111111111111111 N
b1111111111111111111111111111111 R
#70
b1 0
b1 E
b1 G
1/
0-
1I
1#
b1111111111111111111111111111111 !
b1111111111111111111111111111111 1
b1111111111111111111111111111111 F
13
b10000000000000000000000000000001 7
b10000000000000000000000000000001 <
b10000000000000000000000000000001 @
b0 6
b0 ?
b0 A
b1111111111111111111111111111111 .
b1111111111111111111111111111111 D
b1111111111111111111111111111111 Q
b10000000000000000000000000000001 ,
b10000000000000000000000000000001 C
b10000000000000000000000000000001 T
b1 %
b1 (
b1 B
b10000000000000000000000000000001 ;
b101111111111111111111111111111111 P
b10000000000000000000000000000000 $
b10000000000000000000000000000000 '
b10000000000000000000000000000000 8
b10000000000000000000000000000000 =
b10000000000000000000000000000000 N
b10000000000000000000000000000000 R
#80
b0 0
b0 E
b0 G
0/
0L
0"
0H
0#
0M
b0 !
b0 1
b0 F
b11111111111111111111111111110101 *
b11111111111111111111111111110101 O
03
b10100 7
b10100 <
b10100 @
b1010 6
b1010 ?
b1010 A
b0 .
b0 D
b0 Q
b0 ,
b0 C
b0 T
b101 %
b101 (
b101 B
b1010 &
b1010 )
b1010 9
b1010 >
b1010 S
b10100 ;
b100000000000000000000000000000000 P
b1010 $
b1010 '
b1010 8
b1010 =
b1010 N
b1010 R
#90
b1 !
b1 1
b1 F
1L
b1 0
b1 E
b1 G
1/
1-
0M
13
b101 7
b101 <
b101 @
15
b11111111111111111111111111110001 .
b11111111111111111111111111110001 D
b11111111111111111111111111110001 Q
b11111111111111111111111111110001 ,
b11111111111111111111111111110001 C
b11111111111111111111111111110001 T
b100000000000000000000000000000101 ;
b111111111111111111111111111110001 P
b11111111111111111111111111111011 $
b11111111111111111111111111111011 '
b11111111111111111111111111111011 8
b11111111111111111111111111111011 =
b11111111111111111111111111111011 N
b11111111111111111111111111111011 R
#100
0L
1M
b0 0
b0 E
b0 G
0/
0-
0I
1#
b0 !
b0 1
b0 F
b11111111111111111111111111111110 *
b11111111111111111111111111111110 O
b0 7
b0 <
b0 @
b1 6
b1 ?
b1 A
b11111111111111111111111111111110 .
b11111111111111111111111111111110 D
b11111111111111111111111111111110 Q
b11111111111111111111111111111110 ,
b11111111111111111111111111111110 C
b11111111111111111111111111111110 T
b0 %
b0 (
b0 B
b1 &
b1 )
b1 9
b1 >
b1 S
b100000000000000000000000000000000 ;
b111111111111111111111111111111110 P
b11111111111111111111111111111111 $
b11111111111111111111111111111111 '
b11111111111111111111111111111111 8
b11111111111111111111111111111111 =
b11111111111111111111111111111111 N
b11111111111111111111111111111111 R
#120
